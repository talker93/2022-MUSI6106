<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MUSI6106: gtest-matchers.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MUSI6106<span id="projectnumber">&#160;0.0.0.1</span>
   </div>
   <div id="projectbrief">Template Project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_8cab8f464681f7cc51cee77e79a434cd.html">3rdparty</a></li><li class="navelem"><a class="el" href="dir_f12498a9b3b01f7557dfe344f3ca0a3a.html">googletest</a></li><li class="navelem"><a class="el" href="dir_b0bc461411f317819f83da89819c0369.html">googletest</a></li><li class="navelem"><a class="el" href="dir_943c241ef1853b02e7eaa4d020727e0e.html">include</a></li><li class="navelem"><a class="el" href="dir_e64b44ddfb081f905cb46b73b7adc956.html">gtest</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">gtest-matchers.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;atomic&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &quot;<a class="el" href="a00194_source.html">gtest/gtest-printers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="a00212_source.html">gtest/internal/gtest-internal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="a00197_source.html">gtest/internal/gtest-port.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for gtest-matchers.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00240.png" border="0" usemap="#agtest-matchers_8h" alt=""/></div>
<map name="agtest-matchers_8h" id="agtest-matchers_8h">
<area shape="rect" title=" " alt="" coords="393,5,511,32"/>
<area shape="rect" title=" " alt="" coords="5,80,67,107"/>
<area shape="rect" title=" " alt="" coords="349,519,417,546"/>
<area shape="rect" title=" " alt="" coords="192,162,261,189"/>
<area shape="rect" title=" " alt="" coords="599,519,654,546"/>
<area shape="rect" title=" " alt="" coords="241,519,324,546"/>
<area shape="rect" href="a00194.html" title=" " alt="" coords="457,80,599,107"/>
<area shape="rect" href="a00212.html" title=" " alt="" coords="1387,155,1517,196"/>
<area shape="rect" href="a00197.html" title=" " alt="" coords="1311,423,1441,464"/>
<area shape="rect" title=" " alt="" coords="835,162,914,189"/>
<area shape="rect" title=" " alt="" coords="937,430,1007,457"/>
<area shape="rect" title=" " alt="" coords="441,519,492,546"/>
<area shape="rect" title=" " alt="" coords="387,162,439,189"/>
<area shape="rect" title=" " alt="" coords="516,519,575,546"/>
<area shape="rect" href="a01766.html" title=" " alt="" coords="565,155,709,196"/>
<area shape="rect" title=" " alt="" coords="2089,519,2151,546"/>
<area shape="rect" title=" " alt="" coords="2176,519,2240,546"/>
<area shape="rect" title=" " alt="" coords="2264,519,2325,546"/>
<area shape="rect" title=" " alt="" coords="2011,519,2064,546"/>
<area shape="rect" title=" " alt="" coords="1797,251,1853,278"/>
<area shape="rect" title=" " alt="" coords="1877,251,1944,278"/>
<area shape="rect" title=" " alt="" coords="1969,251,2015,278"/>
<area shape="rect" title=" " alt="" coords="1196,251,1236,278"/>
<area shape="rect" href="a00221.html" title=" " alt="" coords="983,341,1134,367"/>
<area shape="rect" href="a00215.html" title=" " alt="" coords="1515,244,1645,285"/>
<area shape="rect" href="a00218.html" title=" " alt="" coords="1516,333,1647,375"/>
<area shape="rect" href="a00209.html" title=" " alt="" coords="1361,333,1492,375"/>
<area shape="rect" title=" " alt="" coords="1747,519,1815,546"/>
<area shape="rect" title=" " alt="" coords="1839,519,1899,546"/>
<area shape="rect" title=" " alt="" coords="1923,519,1986,546"/>
<area shape="rect" title=" " alt="" coords="679,519,737,546"/>
<area shape="rect" title=" " alt="" coords="761,519,833,546"/>
<area shape="rect" title=" " alt="" coords="857,519,913,546"/>
<area shape="rect" title=" " alt="" coords="938,519,1025,546"/>
<area shape="rect" title=" " alt="" coords="1049,519,1127,546"/>
<area shape="rect" href="a01763.html" title=" " alt="" coords="1152,512,1296,553"/>
<area shape="rect" href="a00203.html" title=" " alt="" coords="1320,512,1451,553"/>
<area shape="rect" title=" " alt="" coords="1475,519,1541,546"/>
<area shape="rect" title=" " alt="" coords="1566,519,1637,546"/>
<area shape="rect" title=" " alt="" coords="1661,519,1723,546"/>
</map>
</div>
</div><div class="textblock"><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> This graph shows which files directly or indirectly include this file:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00241.png" border="0" usemap="#agtest-matchers_8hdep" alt=""/></div>
<map name="agtest-matchers_8hdep" id="agtest-matchers_8hdep">
<area shape="rect" title=" " alt="" coords="654,5,773,32"/>
<area shape="rect" href="a00206.html" title=" " alt="" coords="690,80,859,107"/>
<area shape="rect" href="a00191.html" title=" " alt="" coords="671,229,732,256"/>
<area shape="rect" href="a00245.html" title=" " alt="" coords="701,155,824,181"/>
<area shape="rect" href="a00062.html" title=" " alt="" coords="5,311,77,338"/>
<area shape="rect" href="a00275.html" title=" " alt="" coords="232,393,376,420"/>
<area shape="rect" href="a00302.html" title=" " alt="" coords="325,468,477,495"/>
<area shape="rect" href="a00314.html" title=" " alt="" coords="277,692,403,719"/>
<area shape="rect" href="a00290.html" title=" " alt="" coords="462,311,607,338"/>
<area shape="rect" href="a00281.html" title=" " alt="" coords="743,393,873,420"/>
<area shape="rect" href="a00254.html" title=" " alt="" coords="683,304,831,345"/>
<area shape="rect" href="a00248.html" title=" " alt="" coords="897,393,1021,420"/>
<area shape="rect" href="a00236.html" title=" " alt="" coords="907,311,989,338"/>
<area shape="rect" href="a00251.html" title=" " alt="" coords="1014,311,1165,338"/>
<area shape="rect" href="a00230.html" title=" " alt="" coords="1189,311,1313,338"/>
<area shape="rect" href="a00305.html" title=" " alt="" coords="530,617,601,644"/>
<area shape="rect" href="a00308.html" title=" " alt="" coords="360,543,528,569"/>
<area shape="rect" href="a00296.html" title=" " alt="" coords="203,543,335,569"/>
<area shape="rect" href="a00311.html" title=" " alt="" coords="603,393,720,420"/>
<area shape="rect" href="a00293.html" title=" " alt="" coords="654,543,805,569"/>
<area shape="rect" href="a00299.html" title=" " alt="" coords="880,468,1043,495"/>
</map>
</div>
</div>
<p><a href="a00239_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a71fe8dfcd1a8cd227fc47558f26452b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html#a71fe8dfcd1a8cd227fc47558f26452b9">GTEST_MAYBE_5046_</a></td></tr>
<tr class="separator:a71fe8dfcd1a8cd227fc47558f26452b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae9b7a8d33bcb4bbad774b324eeeb23d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html#ae9b7a8d33bcb4bbad774b324eeeb23d6">GTEST_DISABLE_MSC_WARNINGS_PUSH_</a> (4251 <a class="el" href="a00239.html#a71fe8dfcd1a8cd227fc47558f26452b9">GTEST_MAYBE_5046_</a>) namespace testing</td></tr>
<tr class="separator:ae9b7a8d33bcb4bbad774b324eeeb23d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a71fe8dfcd1a8cd227fc47558f26452b9" name="a71fe8dfcd1a8cd227fc47558f26452b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fe8dfcd1a8cd227fc47558f26452b9">&#9670;&nbsp;</a></span>GTEST_MAYBE_5046_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GTEST_MAYBE_5046_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00239_source.html#l00052">52</a> of file <a class="el" href="a00239_source.html">gtest-matchers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae9b7a8d33bcb4bbad774b324eeeb23d6" name="ae9b7a8d33bcb4bbad774b324eeeb23d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b7a8d33bcb4bbad774b324eeeb23d6">&#9670;&nbsp;</a></span>GTEST_DISABLE_MSC_WARNINGS_PUSH_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTEST_DISABLE_MSC_WARNINGS_PUSH_ </td>
          <td>(</td>
          <td class="paramtype">4251&#160;</td>
          <td class="paramname"><em>GTEST_MAYBE_5046_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00239_source.html#l00055">55</a> of file <a class="el" href="a00239_source.html">gtest-matchers.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   60</span>                  {</div>
<div class="line"><span class="lineno">   61</span> </div>
<div class="line"><span class="lineno">   62</span><span class="comment">// To implement a matcher Foo for type T, define:</span></div>
<div class="line"><span class="lineno">   63</span><span class="comment">//   1. a class FooMatcherMatcher that implements the matcher interface:</span></div>
<div class="line"><span class="lineno">   64</span><span class="comment">//     using is_gtest_matcher = void;</span></div>
<div class="line"><span class="lineno">   65</span><span class="comment">//     bool MatchAndExplain(const T&amp;, std::ostream*);</span></div>
<div class="line"><span class="lineno">   66</span><span class="comment">//       (MatchResultListener* can also be used instead of std::ostream*)</span></div>
<div class="line"><span class="lineno">   67</span><span class="comment">//     void DescribeTo(std::ostream*);</span></div>
<div class="line"><span class="lineno">   68</span><span class="comment">//     void DescribeNegationTo(std::ostream*);</span></div>
<div class="line"><span class="lineno">   69</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">   70</span><span class="comment">//   2. a factory function that creates a Matcher&lt;T&gt; object from a</span></div>
<div class="line"><span class="lineno">   71</span><span class="comment">//      FooMatcherMatcher.</span></div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span><span class="keyword">class </span>MatchResultListener {</div>
<div class="line"><span class="lineno">   74</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">   75</span>  <span class="comment">// Creates a listener object with the given underlying ostream.  The</span></div>
<div class="line"><span class="lineno">   76</span>  <span class="comment">// listener does not own the ostream, and does not dereference it</span></div>
<div class="line"><span class="lineno">   77</span>  <span class="comment">// in the constructor or destructor.</span></div>
<div class="line"><span class="lineno">   78</span>  <span class="keyword">explicit</span> MatchResultListener(::std::ostream* os) : stream_(os) {}</div>
<div class="line"><span class="lineno">   79</span>  <span class="keyword">virtual</span> ~MatchResultListener() = 0;  <span class="comment">// Makes this class abstract.</span></div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span>  <span class="comment">// Streams x to the underlying ostream; does nothing if the ostream</span></div>
<div class="line"><span class="lineno">   82</span>  <span class="comment">// is NULL.</span></div>
<div class="line"><span class="lineno">   83</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">   84</span>  MatchResultListener&amp; <a class="code hl_function" href="a00321.html#a2d038049296f23fb404311f974788cd3">operator&lt;&lt;</a>(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line"><span class="lineno">   85</span>    <span class="keywordflow">if</span> (stream_ != <span class="keyword">nullptr</span>) *stream_ &lt;&lt; x;</div>
<div class="line"><span class="lineno">   86</span>    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">   87</span>  }</div>
<div class="line"><span class="lineno">   88</span> </div>
<div class="line"><span class="lineno">   89</span>  <span class="comment">// Returns the underlying ostream.</span></div>
<div class="line"><span class="lineno">   90</span>  ::std::ostream* stream() { <span class="keywordflow">return</span> stream_; }</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>  <span class="comment">// Returns true if and only if the listener is interested in an explanation</span></div>
<div class="line"><span class="lineno">   93</span>  <span class="comment">// of the match result.  A matcher&#39;s MatchAndExplain() method can use</span></div>
<div class="line"><span class="lineno">   94</span>  <span class="comment">// this information to avoid generating the explanation when no one</span></div>
<div class="line"><span class="lineno">   95</span>  <span class="comment">// intends to hear it.</span></div>
<div class="line"><span class="lineno">   96</span>  <span class="keywordtype">bool</span> IsInterested()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> stream_ != <span class="keyword">nullptr</span>; }</div>
<div class="line"><span class="lineno">   97</span> </div>
<div class="line"><span class="lineno">   98</span> <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">   99</span>  ::std::ostream* <span class="keyword">const</span> stream_;</div>
<div class="line"><span class="lineno">  100</span> </div>
<div class="line"><span class="lineno">  101</span>  <a class="code hl_define" href="a00197.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(MatchResultListener);</div>
<div class="line"><span class="lineno">  102</span>};</div>
<div class="line"><span class="lineno">  103</span> </div>
<div class="line"><span class="lineno">  104</span><span class="keyword">inline</span> MatchResultListener::~MatchResultListener() {</div>
<div class="line"><span class="lineno">  105</span>}</div>
<div class="line"><span class="lineno">  106</span> </div>
<div class="line"><span class="lineno">  107</span><span class="comment">// An instance of a subclass of this knows how to describe itself as a</span></div>
<div class="line"><span class="lineno">  108</span><span class="comment">// matcher.</span></div>
<div class="line"><span class="lineno">  109</span><span class="keyword">class </span><a class="code hl_define" href="a00197.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> MatcherDescriberInterface {</div>
<div class="line"><span class="lineno">  110</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  111</span>  <span class="keyword">virtual</span> ~MatcherDescriberInterface() {}</div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span>  <span class="comment">// Describes this matcher to an ostream.  The function should print</span></div>
<div class="line"><span class="lineno">  114</span>  <span class="comment">// a verb phrase that describes the property a value matching this</span></div>
<div class="line"><span class="lineno">  115</span>  <span class="comment">// matcher should have.  The subject of the verb phrase is the value</span></div>
<div class="line"><span class="lineno">  116</span>  <span class="comment">// being matched.  For example, the DescribeTo() method of the Gt(7)</span></div>
<div class="line"><span class="lineno">  117</span>  <span class="comment">// matcher prints &quot;is greater than 7&quot;.</span></div>
<div class="line"><span class="lineno">  118</span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> DescribeTo(::std::ostream* os) <span class="keyword">const</span> = 0;</div>
<div class="line"><span class="lineno">  119</span> </div>
<div class="line"><span class="lineno">  120</span>  <span class="comment">// Describes the negation of this matcher to an ostream.  For</span></div>
<div class="line"><span class="lineno">  121</span>  <span class="comment">// example, if the description of this matcher is &quot;is greater than</span></div>
<div class="line"><span class="lineno">  122</span>  <span class="comment">// 7&quot;, the negated description could be &quot;is not greater than 7&quot;.</span></div>
<div class="line"><span class="lineno">  123</span>  <span class="comment">// You are not required to override this when implementing</span></div>
<div class="line"><span class="lineno">  124</span>  <span class="comment">// MatcherInterface, but it is highly advised so that your matcher</span></div>
<div class="line"><span class="lineno">  125</span>  <span class="comment">// can produce good error messages.</span></div>
<div class="line"><span class="lineno">  126</span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> DescribeNegationTo(::std::ostream* os)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  127</span>    *os &lt;&lt; <span class="stringliteral">&quot;not (&quot;</span>;</div>
<div class="line"><span class="lineno">  128</span>    DescribeTo(os);</div>
<div class="line"><span class="lineno">  129</span>    *os &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><span class="lineno">  130</span>  }</div>
<div class="line"><span class="lineno">  131</span>};</div>
<div class="line"><span class="lineno">  132</span> </div>
<div class="line"><span class="lineno">  133</span><span class="comment">// The implementation of a matcher.</span></div>
<div class="line"><span class="lineno">  134</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  135</span><span class="keyword">class </span>MatcherInterface : <span class="keyword">public</span> MatcherDescriberInterface {</div>
<div class="line"><span class="lineno">  136</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  137</span>  <span class="comment">// Returns true if and only if the matcher matches x; also explains the</span></div>
<div class="line"><span class="lineno">  138</span>  <span class="comment">// match result to &#39;listener&#39; if necessary (see the next paragraph), in</span></div>
<div class="line"><span class="lineno">  139</span>  <span class="comment">// the form of a non-restrictive relative clause (&quot;which ...&quot;,</span></div>
<div class="line"><span class="lineno">  140</span>  <span class="comment">// &quot;whose ...&quot;, etc) that describes x.  For example, the</span></div>
<div class="line"><span class="lineno">  141</span>  <span class="comment">// MatchAndExplain() method of the Pointee(...) matcher should</span></div>
<div class="line"><span class="lineno">  142</span>  <span class="comment">// generate an explanation like &quot;which points to ...&quot;.</span></div>
<div class="line"><span class="lineno">  143</span>  <span class="comment">//</span></div>
<div class="line"><span class="lineno">  144</span>  <span class="comment">// Implementations of MatchAndExplain() should add an explanation of</span></div>
<div class="line"><span class="lineno">  145</span>  <span class="comment">// the match result *if and only if* they can provide additional</span></div>
<div class="line"><span class="lineno">  146</span>  <span class="comment">// information that&#39;s not already present (or not obvious) in the</span></div>
<div class="line"><span class="lineno">  147</span>  <span class="comment">// print-out of x and the matcher&#39;s description.  Whether the match</span></div>
<div class="line"><span class="lineno">  148</span>  <span class="comment">// succeeds is not a factor in deciding whether an explanation is</span></div>
<div class="line"><span class="lineno">  149</span>  <span class="comment">// needed, as sometimes the caller needs to print a failure message</span></div>
<div class="line"><span class="lineno">  150</span>  <span class="comment">// when the match succeeds (e.g. when the matcher is used inside</span></div>
<div class="line"><span class="lineno">  151</span>  <span class="comment">// Not()).</span></div>
<div class="line"><span class="lineno">  152</span>  <span class="comment">//</span></div>
<div class="line"><span class="lineno">  153</span>  <span class="comment">// For example, a &quot;has at least 10 elements&quot; matcher should explain</span></div>
<div class="line"><span class="lineno">  154</span>  <span class="comment">// what the actual element count is, regardless of the match result,</span></div>
<div class="line"><span class="lineno">  155</span>  <span class="comment">// as it is useful information to the reader; on the other hand, an</span></div>
<div class="line"><span class="lineno">  156</span>  <span class="comment">// &quot;is empty&quot; matcher probably only needs to explain what the actual</span></div>
<div class="line"><span class="lineno">  157</span>  <span class="comment">// size is when the match fails, as it&#39;s redundant to say that the</span></div>
<div class="line"><span class="lineno">  158</span>  <span class="comment">// size is 0 when the value is already known to be empty.</span></div>
<div class="line"><span class="lineno">  159</span>  <span class="comment">//</span></div>
<div class="line"><span class="lineno">  160</span>  <span class="comment">// You should override this method when defining a new matcher.</span></div>
<div class="line"><span class="lineno">  161</span>  <span class="comment">//</span></div>
<div class="line"><span class="lineno">  162</span>  <span class="comment">// It&#39;s the responsibility of the caller (Google Test) to guarantee</span></div>
<div class="line"><span class="lineno">  163</span>  <span class="comment">// that &#39;listener&#39; is not NULL.  This helps to simplify a matcher&#39;s</span></div>
<div class="line"><span class="lineno">  164</span>  <span class="comment">// implementation when it doesn&#39;t care about the performance, as it</span></div>
<div class="line"><span class="lineno">  165</span>  <span class="comment">// can talk to &#39;listener&#39; without checking its validity first.</span></div>
<div class="line"><span class="lineno">  166</span>  <span class="comment">// However, in order to implement dummy listeners efficiently,</span></div>
<div class="line"><span class="lineno">  167</span>  <span class="comment">// listener-&gt;stream() may be NULL.</span></div>
<div class="line"><span class="lineno">  168</span>  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> MatchAndExplain(T x, MatchResultListener* listener) <span class="keyword">const</span> = 0;</div>
<div class="line"><span class="lineno">  169</span> </div>
<div class="line"><span class="lineno">  170</span>  <span class="comment">// Inherits these methods from MatcherDescriberInterface:</span></div>
<div class="line"><span class="lineno">  171</span>  <span class="comment">//   virtual void DescribeTo(::std::ostream* os) const = 0;</span></div>
<div class="line"><span class="lineno">  172</span>  <span class="comment">//   virtual void DescribeNegationTo(::std::ostream* os) const;</span></div>
<div class="line"><span class="lineno">  173</span>};</div>
<div class="line"><span class="lineno">  174</span> </div>
<div class="line"><span class="lineno">  175</span><span class="keyword">namespace </span>internal {</div>
<div class="line"><span class="lineno">  176</span> </div>
<div class="line"><span class="lineno">  177</span><span class="keyword">struct </span>AnyEq {</div>
<div class="line"><span class="lineno">  178</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div>
<div class="line"><span class="lineno">  179</span>  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> a == b; }</div>
<div class="line"><span class="lineno">  180</span>};</div>
<div class="line"><span class="lineno">  181</span><span class="keyword">struct </span>AnyNe {</div>
<div class="line"><span class="lineno">  182</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div>
<div class="line"><span class="lineno">  183</span>  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> a != b; }</div>
<div class="line"><span class="lineno">  184</span>};</div>
<div class="line"><span class="lineno">  185</span><span class="keyword">struct </span>AnyLt {</div>
<div class="line"><span class="lineno">  186</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div>
<div class="line"><span class="lineno">  187</span>  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> a &lt; b; }</div>
<div class="line"><span class="lineno">  188</span>};</div>
<div class="line"><span class="lineno">  189</span><span class="keyword">struct </span>AnyGt {</div>
<div class="line"><span class="lineno">  190</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div>
<div class="line"><span class="lineno">  191</span>  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> a &gt; b; }</div>
<div class="line"><span class="lineno">  192</span>};</div>
<div class="line"><span class="lineno">  193</span><span class="keyword">struct </span>AnyLe {</div>
<div class="line"><span class="lineno">  194</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div>
<div class="line"><span class="lineno">  195</span>  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> a &lt;= b; }</div>
<div class="line"><span class="lineno">  196</span>};</div>
<div class="line"><span class="lineno">  197</span><span class="keyword">struct </span>AnyGe {</div>
<div class="line"><span class="lineno">  198</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</div>
<div class="line"><span class="lineno">  199</span>  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> a &gt;= b; }</div>
<div class="line"><span class="lineno">  200</span>};</div>
<div class="line"><span class="lineno">  201</span> </div>
<div class="line"><span class="lineno">  202</span><span class="comment">// A match result listener that ignores the explanation.</span></div>
<div class="line"><span class="lineno">  203</span><span class="keyword">class </span>DummyMatchResultListener : <span class="keyword">public</span> MatchResultListener {</div>
<div class="line"><span class="lineno">  204</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  205</span>  DummyMatchResultListener() : MatchResultListener(nullptr) {}</div>
<div class="line"><span class="lineno">  206</span> </div>
<div class="line"><span class="lineno">  207</span> <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">  208</span>  <a class="code hl_define" href="a00197.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(DummyMatchResultListener);</div>
<div class="line"><span class="lineno">  209</span>};</div>
<div class="line"><span class="lineno">  210</span> </div>
<div class="line"><span class="lineno">  211</span><span class="comment">// A match result listener that forwards the explanation to a given</span></div>
<div class="line"><span class="lineno">  212</span><span class="comment">// ostream.  The difference between this and MatchResultListener is</span></div>
<div class="line"><span class="lineno">  213</span><span class="comment">// that the former is concrete.</span></div>
<div class="line"><span class="lineno">  214</span><span class="keyword">class </span>StreamMatchResultListener : <span class="keyword">public</span> MatchResultListener {</div>
<div class="line"><span class="lineno">  215</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  216</span>  <span class="keyword">explicit</span> StreamMatchResultListener(::std::ostream* os)</div>
<div class="line"><span class="lineno">  217</span>      : MatchResultListener(os) {}</div>
<div class="line"><span class="lineno">  218</span> </div>
<div class="line"><span class="lineno">  219</span> <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">  220</span>  <a class="code hl_define" href="a00197.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(StreamMatchResultListener);</div>
<div class="line"><span class="lineno">  221</span>};</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span><span class="keyword">struct </span>SharedPayloadBase {</div>
<div class="line"><span class="lineno">  224</span>  std::atomic&lt;int&gt; ref{1};</div>
<div class="line"><span class="lineno">  225</span>  <span class="keywordtype">void</span> Ref() { ref.fetch_add(1, std::memory_order_relaxed); }</div>
<div class="line"><span class="lineno">  226</span>  <span class="keywordtype">bool</span> Unref() { <span class="keywordflow">return</span> ref.fetch_sub(1, std::memory_order_acq_rel) == 1; }</div>
<div class="line"><span class="lineno">  227</span>};</div>
<div class="line"><span class="lineno">  228</span> </div>
<div class="line"><span class="lineno">  229</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  230</span><span class="keyword">struct </span>SharedPayload : SharedPayloadBase {</div>
<div class="line"><span class="lineno">  231</span>  <span class="keyword">explicit</span> SharedPayload(<span class="keyword">const</span> T&amp; v) : value(v) {}</div>
<div class="line"><span class="lineno">  232</span>  <span class="keyword">explicit</span> SharedPayload(T&amp;&amp; v) : value(<a class="code hl_namespace" href="a00327.html">std</a>::move(v)) {}</div>
<div class="line"><span class="lineno">  233</span> </div>
<div class="line"><span class="lineno">  234</span>  <span class="keyword">static</span> <span class="keywordtype">void</span> Destroy(SharedPayloadBase* shared) {</div>
<div class="line"><span class="lineno">  235</span>    <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>SharedPayload*<span class="keyword">&gt;</span>(shared);</div>
<div class="line"><span class="lineno">  236</span>  }</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span>  T value;</div>
<div class="line"><span class="lineno">  239</span>};</div>
<div class="line"><span class="lineno">  240</span> </div>
<div class="line"><span class="lineno">  241</span><span class="comment">// An internal class for implementing Matcher&lt;T&gt;, which will derive</span></div>
<div class="line"><span class="lineno">  242</span><span class="comment">// from it.  We put functionalities common to all Matcher&lt;T&gt;</span></div>
<div class="line"><span class="lineno">  243</span><span class="comment">// specializations here to avoid code duplication.</span></div>
<div class="line"><span class="lineno">  244</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  245</span><span class="keyword">class </span>MatcherBase : <span class="keyword">private</span> MatcherDescriberInterface {</div>
<div class="line"><span class="lineno">  246</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  247</span>  <span class="comment">// Returns true if and only if the matcher matches x; also explains the</span></div>
<div class="line"><span class="lineno">  248</span>  <span class="comment">// match result to &#39;listener&#39;.</span></div>
<div class="line"><span class="lineno">  249</span>  <span class="keywordtype">bool</span> MatchAndExplain(<span class="keyword">const</span> T&amp; x, MatchResultListener* listener)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  250</span>    <a class="code hl_define" href="a00197.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(vtable_ != <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  251</span>    <span class="keywordflow">return</span> vtable_-&gt;match_and_explain(*<span class="keyword">this</span>, x, listener);</div>
<div class="line"><span class="lineno">  252</span>  }</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>  <span class="comment">// Returns true if and only if this matcher matches x.</span></div>
<div class="line"><span class="lineno">  255</span>  <span class="keywordtype">bool</span> Matches(<span class="keyword">const</span> T&amp; x)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  256</span>    DummyMatchResultListener dummy;</div>
<div class="line"><span class="lineno">  257</span>    <span class="keywordflow">return</span> MatchAndExplain(x, &amp;dummy);</div>
<div class="line"><span class="lineno">  258</span>  }</div>
<div class="line"><span class="lineno">  259</span> </div>
<div class="line"><span class="lineno">  260</span>  <span class="comment">// Describes this matcher to an ostream.</span></div>
<div class="line"><span class="lineno">  261</span>  <span class="keywordtype">void</span> DescribeTo(::std::ostream* os) <span class="keyword">const</span> <span class="keyword">final</span> {</div>
<div class="line"><span class="lineno">  262</span>    <a class="code hl_define" href="a00197.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(vtable_ != <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  263</span>    vtable_-&gt;describe(*<span class="keyword">this</span>, os, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  264</span>  }</div>
<div class="line"><span class="lineno">  265</span> </div>
<div class="line"><span class="lineno">  266</span>  <span class="comment">// Describes the negation of this matcher to an ostream.</span></div>
<div class="line"><span class="lineno">  267</span>  <span class="keywordtype">void</span> DescribeNegationTo(::std::ostream* os) <span class="keyword">const</span> <span class="keyword">final</span> {</div>
<div class="line"><span class="lineno">  268</span>    <a class="code hl_define" href="a00197.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(vtable_ != <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  269</span>    vtable_-&gt;describe(*<span class="keyword">this</span>, os, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  270</span>  }</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span>  <span class="comment">// Explains why x matches, or doesn&#39;t match, the matcher.</span></div>
<div class="line"><span class="lineno">  273</span>  <span class="keywordtype">void</span> ExplainMatchResultTo(<span class="keyword">const</span> T&amp; x, ::std::ostream* os)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  274</span>    StreamMatchResultListener listener(os);</div>
<div class="line"><span class="lineno">  275</span>    MatchAndExplain(x, &amp;listener);</div>
<div class="line"><span class="lineno">  276</span>  }</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>  <span class="comment">// Returns the describer for this matcher object; retains ownership</span></div>
<div class="line"><span class="lineno">  279</span>  <span class="comment">// of the describer, which is only guaranteed to be alive when</span></div>
<div class="line"><span class="lineno">  280</span>  <span class="comment">// this matcher object is alive.</span></div>
<div class="line"><span class="lineno">  281</span>  <span class="keyword">const</span> MatcherDescriberInterface* GetDescriber()<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  282</span>    <span class="keywordflow">if</span> (vtable_ == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  283</span>    <span class="keywordflow">return</span> vtable_-&gt;get_describer(*<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">  284</span>  }</div>
<div class="line"><span class="lineno">  285</span> </div>
<div class="line"><span class="lineno">  286</span> <span class="keyword">protected</span>:</div>
<div class="line"><span class="lineno">  287</span>  MatcherBase() : vtable_(nullptr) {}</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span>  <span class="comment">// Constructs a matcher from its implementation.</span></div>
<div class="line"><span class="lineno">  290</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</div>
<div class="line"><span class="lineno">  291</span>  <span class="keyword">explicit</span> MatcherBase(<span class="keyword">const</span> MatcherInterface&lt;U&gt;* impl) {</div>
<div class="line"><span class="lineno">  292</span>    Init(impl);</div>
<div class="line"><span class="lineno">  293</span>  }</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::remove_reference&lt;</div>
<div class="line"><span class="lineno">  296</span>                            M&gt;::type::is_gtest_matcher&gt;</div>
<div class="line"><span class="lineno">  297</span>  MatcherBase(M&amp;&amp; m) {  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  298</span>    Init(std::forward&lt;M&gt;(m));</div>
<div class="line"><span class="lineno">  299</span>  }</div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span>  MatcherBase(<span class="keyword">const</span> MatcherBase&amp; other)</div>
<div class="line"><span class="lineno">  302</span>      : vtable_(other.vtable_), buffer_(other.buffer_) {</div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">if</span> (IsShared()) buffer_.shared-&gt;Ref();</div>
<div class="line"><span class="lineno">  304</span>  }</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span>  MatcherBase&amp; operator=(<span class="keyword">const</span> MatcherBase&amp; other) {</div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  308</span>    Destroy();</div>
<div class="line"><span class="lineno">  309</span>    vtable_ = other.vtable_;</div>
<div class="line"><span class="lineno">  310</span>    buffer_ = other.buffer_;</div>
<div class="line"><span class="lineno">  311</span>    <span class="keywordflow">if</span> (IsShared()) buffer_.shared-&gt;Ref();</div>
<div class="line"><span class="lineno">  312</span>    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  313</span>  }</div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span>  MatcherBase(MatcherBase&amp;&amp; other)</div>
<div class="line"><span class="lineno">  316</span>      : vtable_(other.vtable_), buffer_(other.buffer_) {</div>
<div class="line"><span class="lineno">  317</span>    other.vtable_ = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  318</span>  }</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>  MatcherBase&amp; operator=(MatcherBase&amp;&amp; other) {</div>
<div class="line"><span class="lineno">  321</span>    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  322</span>    Destroy();</div>
<div class="line"><span class="lineno">  323</span>    vtable_ = other.vtable_;</div>
<div class="line"><span class="lineno">  324</span>    buffer_ = other.buffer_;</div>
<div class="line"><span class="lineno">  325</span>    other.vtable_ = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  326</span>    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  327</span>  }</div>
<div class="line"><span class="lineno">  328</span> </div>
<div class="line"><span class="lineno">  329</span>  ~MatcherBase()<span class="keyword"> override </span>{ Destroy(); }</div>
<div class="line"><span class="lineno">  330</span> </div>
<div class="line"><span class="lineno">  331</span> <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">  332</span>  <span class="keyword">struct </span>VTable {</div>
<div class="line"><span class="lineno">  333</span>    <a class="code hl_define" href="a00116.html#abb452686968e48b67397da5f97445f5b">bool</a> (*match_and_explain)(<span class="keyword">const</span> MatcherBase&amp;, <span class="keyword">const</span> T&amp;,</div>
<div class="line"><span class="lineno">  334</span>                              MatchResultListener*);</div>
<div class="line"><span class="lineno">  335</span>    void (*describe)(<span class="keyword">const</span> MatcherBase&amp;, std::ostream*, <span class="keywordtype">bool</span> negation);</div>
<div class="line"><span class="lineno">  336</span>    <span class="comment">// Returns the captured object if it implements the interface, otherwise</span></div>
<div class="line"><span class="lineno">  337</span>    <span class="comment">// returns the MatcherBase itself.</span></div>
<div class="line"><span class="lineno">  338</span>    <span class="keyword">const</span> MatcherDescriberInterface* (*get_describer)(<span class="keyword">const</span> MatcherBase&amp;);</div>
<div class="line"><span class="lineno">  339</span>    <span class="comment">// Called on shared instances when the reference count reaches 0.</span></div>
<div class="line"><span class="lineno">  340</span>    void (*shared_destroy)(SharedPayloadBase*);</div>
<div class="line"><span class="lineno">  341</span>  };</div>
<div class="line"><span class="lineno">  342</span> </div>
<div class="line"><span class="lineno">  343</span>  <span class="keywordtype">bool</span> IsShared()<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  344</span>    <span class="keywordflow">return</span> vtable_ != <span class="keyword">nullptr</span> &amp;&amp; vtable_-&gt;shared_destroy != <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  345</span>  }</div>
<div class="line"><span class="lineno">  346</span> </div>
<div class="line"><span class="lineno">  347</span>  <span class="comment">// If the implementation uses a listener, call that.</span></div>
<div class="line"><span class="lineno">  348</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;</div>
<div class="line"><span class="lineno">  349</span>  <span class="keyword">static</span> <span class="keyword">auto</span> MatchAndExplainImpl(<span class="keyword">const</span> MatcherBase&amp; m, <span class="keyword">const</span> T&amp; value,</div>
<div class="line"><span class="lineno">  350</span>                                  MatchResultListener* listener)</div>
<div class="line"><span class="lineno">  351</span>      -&gt; <span class="keyword">decltype</span>(P::Get(m).MatchAndExplain(value, listener-&gt;stream())) {</div>
<div class="line"><span class="lineno">  352</span>    <span class="keywordflow">return</span> P::Get(m).MatchAndExplain(value, listener-&gt;stream());</div>
<div class="line"><span class="lineno">  353</span>  }</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;</div>
<div class="line"><span class="lineno">  356</span>  <span class="keyword">static</span> <span class="keyword">auto</span> MatchAndExplainImpl(<span class="keyword">const</span> MatcherBase&amp; m, <span class="keyword">const</span> T&amp; value,</div>
<div class="line"><span class="lineno">  357</span>                                  MatchResultListener* listener)</div>
<div class="line"><span class="lineno">  358</span>      -&gt; <span class="keyword">decltype</span>(P::Get(m).MatchAndExplain(value, listener)) {</div>
<div class="line"><span class="lineno">  359</span>    <span class="keywordflow">return</span> P::Get(m).MatchAndExplain(value, listener);</div>
<div class="line"><span class="lineno">  360</span>  }</div>
<div class="line"><span class="lineno">  361</span> </div>
<div class="line"><span class="lineno">  362</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;</div>
<div class="line"><span class="lineno">  363</span>  <span class="keyword">static</span> <span class="keywordtype">void</span> DescribeImpl(<span class="keyword">const</span> MatcherBase&amp; m, std::ostream* os,</div>
<div class="line"><span class="lineno">  364</span>                           <span class="keywordtype">bool</span> negation) {</div>
<div class="line"><span class="lineno">  365</span>    <span class="keywordflow">if</span> (negation) {</div>
<div class="line"><span class="lineno">  366</span>      P::Get(m).DescribeNegationTo(os);</div>
<div class="line"><span class="lineno">  367</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  368</span>      P::Get(m).DescribeTo(os);</div>
<div class="line"><span class="lineno">  369</span>    }</div>
<div class="line"><span class="lineno">  370</span>  }</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;</div>
<div class="line"><span class="lineno">  373</span>  <span class="keyword">static</span> <span class="keyword">const</span> MatcherDescriberInterface* GetDescriberImpl(</div>
<div class="line"><span class="lineno">  374</span>      <span class="keyword">const</span> MatcherBase&amp; m) {</div>
<div class="line"><span class="lineno">  375</span>    <span class="comment">// If the impl is a MatcherDescriberInterface, then return it.</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="comment">// Otherwise use MatcherBase itself.</span></div>
<div class="line"><span class="lineno">  377</span>    <span class="comment">// This allows us to implement the GetDescriber() function without support</span></div>
<div class="line"><span class="lineno">  378</span>    <span class="comment">// from the impl, but some users really want to get their impl back when</span></div>
<div class="line"><span class="lineno">  379</span>    <span class="comment">// they call GetDescriber().</span></div>
<div class="line"><span class="lineno">  380</span>    <span class="comment">// We use std::get on a tuple as a workaround of not having `if constexpr`.</span></div>
<div class="line"><span class="lineno">  381</span>    <span class="keywordflow">return</span> std::get&lt;(</div>
<div class="line"><span class="lineno">  382</span>        std::is_convertible&lt;<span class="keyword">decltype</span>(&amp;P::Get(m)),</div>
<div class="line"><span class="lineno">  383</span>                            <span class="keyword">const</span> MatcherDescriberInterface*&gt;::value</div>
<div class="line"><span class="lineno">  384</span>            ? 1</div>
<div class="line"><span class="lineno">  385</span>            : 0)&gt;(std::make_tuple(&amp;m, &amp;P::Get(m)));</div>
<div class="line"><span class="lineno">  386</span>  }</div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;</div>
<div class="line"><span class="lineno">  389</span>  <span class="keyword">const</span> VTable* GetVTable() {</div>
<div class="line"><span class="lineno">  390</span>    <span class="keyword">static</span> <span class="keyword">constexpr</span> VTable kVTable = {&amp;MatchAndExplainImpl&lt;P&gt;,</div>
<div class="line"><span class="lineno">  391</span>                                       &amp;DescribeImpl&lt;P&gt;, &amp;GetDescriberImpl&lt;P&gt;,</div>
<div class="line"><span class="lineno">  392</span>                                       P::shared_destroy};</div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">return</span> &amp;kVTable;</div>
<div class="line"><span class="lineno">  394</span>  }</div>
<div class="line"><span class="lineno">  395</span> </div>
<div class="line"><span class="lineno">  396</span>  <span class="keyword">union </span>Buffer {</div>
<div class="line"><span class="lineno">  397</span>    <span class="comment">// Add some types to give Buffer some common alignment/size use cases.</span></div>
<div class="line"><span class="lineno">  398</span>    <span class="keywordtype">void</span>* ptr;</div>
<div class="line"><span class="lineno">  399</span>    <span class="keywordtype">double</span> d;</div>
<div class="line"><span class="lineno">  400</span>    int64_t i;</div>
<div class="line"><span class="lineno">  401</span>    <span class="comment">// And add one for the out-of-line cases.</span></div>
<div class="line"><span class="lineno">  402</span>    SharedPayloadBase* shared;</div>
<div class="line"><span class="lineno">  403</span>  };</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>  <span class="keywordtype">void</span> Destroy() {</div>
<div class="line"><span class="lineno">  406</span>    <span class="keywordflow">if</span> (IsShared() &amp;&amp; buffer_.shared-&gt;Unref()) {</div>
<div class="line"><span class="lineno">  407</span>      vtable_-&gt;shared_destroy(buffer_.shared);</div>
<div class="line"><span class="lineno">  408</span>    }</div>
<div class="line"><span class="lineno">  409</span>  }</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M&gt;</div>
<div class="line"><span class="lineno">  412</span>  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> IsInlined() {</div>
<div class="line"><span class="lineno">  413</span>    <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(M) &lt;= <span class="keyword">sizeof</span>(Buffer) &amp;&amp; <span class="keyword">alignof</span>(M) &lt;= <span class="keyword">alignof</span>(Buffer) &amp;&amp;</div>
<div class="line"><span class="lineno">  414</span>           std::is_trivially_copy_constructible&lt;M&gt;::value &amp;&amp;</div>
<div class="line"><span class="lineno">  415</span>           std::is_trivially_destructible&lt;M&gt;::value;</div>
<div class="line"><span class="lineno">  416</span>  }</div>
<div class="line"><span class="lineno">  417</span> </div>
<div class="line"><span class="lineno">  418</span>  template &lt;typename M, bool = MatcherBase::IsInlined&lt;M&gt;()&gt;</div>
<div class="line"><span class="lineno">  419</span>  <span class="keyword">struct </span>ValuePolicy {</div>
<div class="line"><span class="lineno">  420</span>    <span class="keyword">static</span> <span class="keyword">const</span> M&amp; Get(<span class="keyword">const</span> MatcherBase&amp; m) {</div>
<div class="line"><span class="lineno">  421</span>      <span class="comment">// When inlined along with Init, need to be explicit to avoid violating</span></div>
<div class="line"><span class="lineno">  422</span>      <span class="comment">// strict aliasing rules.</span></div>
<div class="line"><span class="lineno">  423</span>      <span class="keyword">const</span> M *ptr = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>M*<span class="keyword">&gt;</span>(</div>
<div class="line"><span class="lineno">  424</span>          <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;m.buffer_));</div>
<div class="line"><span class="lineno">  425</span>      <span class="keywordflow">return</span> *ptr;</div>
<div class="line"><span class="lineno">  426</span>    }</div>
<div class="line"><span class="lineno">  427</span>    <span class="keyword">static</span> <span class="keywordtype">void</span> Init(MatcherBase&amp; m, M impl) {</div>
<div class="line"><span class="lineno">  428</span>      ::new (<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;m.buffer_)) M(impl);</div>
<div class="line"><span class="lineno">  429</span>    }</div>
<div class="line"><span class="lineno">  430</span>    static constexpr auto shared_destroy = <span class="keywordtype">nullptr</span>;</div>
<div class="line"><span class="lineno">  431</span>  };</div>
<div class="line"><span class="lineno">  432</span> </div>
<div class="line"><span class="lineno">  433</span>  template &lt;typename M&gt;</div>
<div class="line"><span class="lineno">  434</span>  struct ValuePolicy&lt;M, <a class="code hl_define" href="a00116.html#a65e9886d74aaee76545e83dd09011727">false</a>&gt; {</div>
<div class="line"><span class="lineno">  435</span>    <span class="keyword">using</span> Shared = SharedPayload&lt;M&gt;;</div>
<div class="line"><span class="lineno">  436</span>    <span class="keyword">static</span> <span class="keyword">const</span> M&amp; Get(<span class="keyword">const</span> MatcherBase&amp; m) {</div>
<div class="line"><span class="lineno">  437</span>      <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Shared*<span class="keyword">&gt;</span>(m.buffer_.shared)-&gt;value;</div>
<div class="line"><span class="lineno">  438</span>    }</div>
<div class="line"><span class="lineno">  439</span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg&gt;</div>
<div class="line"><span class="lineno">  440</span>    <span class="keyword">static</span> <span class="keywordtype">void</span> Init(MatcherBase&amp; m, Arg&amp;&amp; arg) {</div>
<div class="line"><span class="lineno">  441</span>      m.buffer_.shared = <span class="keyword">new</span> Shared(std::forward&lt;Arg&gt;(arg));</div>
<div class="line"><span class="lineno">  442</span>    }</div>
<div class="line"><span class="lineno">  443</span>    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> shared_destroy = &amp;Shared::Destroy;</div>
<div class="line"><span class="lineno">  444</span>  };</div>
<div class="line"><span class="lineno">  445</span> </div>
<div class="line"><span class="lineno">  446</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keywordtype">bool</span> B&gt;</div>
<div class="line"><span class="lineno">  447</span>  <span class="keyword">struct </span>ValuePolicy&lt;const MatcherInterface&lt;U&gt;*, B&gt; {</div>
<div class="line"><span class="lineno">  448</span>    <span class="keyword">using</span> M = <span class="keyword">const</span> MatcherInterface&lt;U&gt;;</div>
<div class="line"><span class="lineno">  449</span>    <span class="keyword">using</span> Shared = SharedPayload&lt;std::unique_ptr&lt;M&gt;&gt;;</div>
<div class="line"><span class="lineno">  450</span>    <span class="keyword">static</span> <span class="keyword">const</span> M&amp; Get(<span class="keyword">const</span> MatcherBase&amp; m) {</div>
<div class="line"><span class="lineno">  451</span>      <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span>Shared*<span class="keyword">&gt;</span>(m.buffer_.shared)-&gt;value;</div>
<div class="line"><span class="lineno">  452</span>    }</div>
<div class="line"><span class="lineno">  453</span>    <span class="keyword">static</span> <span class="keywordtype">void</span> Init(MatcherBase&amp; m, M* impl) {</div>
<div class="line"><span class="lineno">  454</span>      m.buffer_.shared = <span class="keyword">new</span> Shared(std::unique_ptr&lt;M&gt;(impl));</div>
<div class="line"><span class="lineno">  455</span>    }</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> shared_destroy = &amp;Shared::Destroy;</div>
<div class="line"><span class="lineno">  458</span>  };</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M&gt;</div>
<div class="line"><span class="lineno">  461</span>  <span class="keywordtype">void</span> Init(M&amp;&amp; m) {</div>
<div class="line"><span class="lineno">  462</span>    <span class="keyword">using</span> MM = <span class="keyword">typename</span> std::decay&lt;M&gt;::type;</div>
<div class="line"><span class="lineno">  463</span>    <span class="keyword">using</span> Policy = ValuePolicy&lt;MM&gt;;</div>
<div class="line"><span class="lineno">  464</span>    vtable_ = GetVTable&lt;Policy&gt;();</div>
<div class="line"><span class="lineno">  465</span>    Policy::Init(*<span class="keyword">this</span>, std::forward&lt;M&gt;(m));</div>
<div class="line"><span class="lineno">  466</span>  }</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>  <span class="keyword">const</span> VTable* vtable_;</div>
<div class="line"><span class="lineno">  469</span>  Buffer buffer_;</div>
<div class="line"><span class="lineno">  470</span>};</div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>}  <span class="comment">// namespace internal</span></div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span><span class="comment">// A Matcher&lt;T&gt; is a copyable and IMMUTABLE (except by assignment)</span></div>
<div class="line"><span class="lineno">  475</span><span class="comment">// object that can check whether a value of type T matches.  The</span></div>
<div class="line"><span class="lineno">  476</span><span class="comment">// implementation of Matcher&lt;T&gt; is just a std::shared_ptr to const</span></div>
<div class="line"><span class="lineno">  477</span><span class="comment">// MatcherInterface&lt;T&gt;.  Don&#39;t inherit from Matcher!</span></div>
<div class="line"><span class="lineno">  478</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  479</span><span class="keyword">class </span>Matcher : <span class="keyword">public</span> internal::MatcherBase&lt;T&gt; {</div>
<div class="line"><span class="lineno">  480</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  481</span>  <span class="comment">// Constructs a null matcher.  Needed for storing Matcher objects in STL</span></div>
<div class="line"><span class="lineno">  482</span>  <span class="comment">// containers.  A default-constructed matcher is not yet initialized.  You</span></div>
<div class="line"><span class="lineno">  483</span>  <span class="comment">// cannot use it until a valid value has been assigned to it.</span></div>
<div class="line"><span class="lineno">  484</span>  <span class="keyword">explicit</span> Matcher() {}  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  485</span> </div>
<div class="line"><span class="lineno">  486</span>  <span class="comment">// Constructs a matcher from its implementation.</span></div>
<div class="line"><span class="lineno">  487</span>  <span class="keyword">explicit</span> Matcher(<span class="keyword">const</span> MatcherInterface&lt;const T&amp;&gt;* impl)</div>
<div class="line"><span class="lineno">  488</span>      : internal::MatcherBase&lt;T&gt;(impl) {}</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</div>
<div class="line"><span class="lineno">  491</span>  <span class="keyword">explicit</span> Matcher(</div>
<div class="line"><span class="lineno">  492</span>      <span class="keyword">const</span> MatcherInterface&lt;U&gt;* impl,</div>
<div class="line"><span class="lineno">  493</span>      <span class="keyword">typename</span> std::enable_if&lt;!std::is_same&lt;U, const U&amp;&gt;::value&gt;::type* =</div>
<div class="line"><span class="lineno">  494</span>          <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  495</span>      : internal::MatcherBase&lt;T&gt;(impl) {}</div>
<div class="line"><span class="lineno">  496</span> </div>
<div class="line"><span class="lineno">  497</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::remove_reference&lt;</div>
<div class="line"><span class="lineno">  498</span>                            M&gt;::type::is_gtest_matcher&gt;</div>
<div class="line"><span class="lineno">  499</span>  Matcher(M&amp;&amp; m) : internal::MatcherBase&lt;T&gt;(<a class="code hl_namespace" href="a00327.html">std</a>::forward&lt;M&gt;(m)) {}  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  501</span>  <span class="comment">// Implicit constructor here allows people to write</span></div>
<div class="line"><span class="lineno">  502</span>  <span class="comment">// EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes</span></div>
<div class="line"><span class="lineno">  503</span>  Matcher(T value);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  504</span>};</div>
<div class="line"><span class="lineno">  505</span> </div>
<div class="line"><span class="lineno">  506</span><span class="comment">// The following two specializations allow the user to write str</span></div>
<div class="line"><span class="lineno">  507</span><span class="comment">// instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a std::string</span></div>
<div class="line"><span class="lineno">  508</span><span class="comment">// matcher is expected.</span></div>
<div class="line"><span class="lineno">  509</span><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="lineno">  510</span><span class="keyword">class </span><a class="code hl_define" href="a00197.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> Matcher&lt;const <a class="code hl_namespace" href="a00327.html">std</a>::string&amp;&gt;</div>
<div class="line"><span class="lineno">  511</span>    : <span class="keyword">public</span> internal::MatcherBase&lt;const std::string&amp;&gt; {</div>
<div class="line"><span class="lineno">  512</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  513</span>  Matcher() {}</div>
<div class="line"><span class="lineno">  514</span> </div>
<div class="line"><span class="lineno">  515</span>  <span class="keyword">explicit</span> Matcher(<span class="keyword">const</span> MatcherInterface&lt;const std::string&amp;&gt;* impl)</div>
<div class="line"><span class="lineno">  516</span>      : internal::MatcherBase&lt;const <a class="code hl_namespace" href="a00327.html">std</a>::string&amp;&gt;(impl) {}</div>
<div class="line"><span class="lineno">  517</span> </div>
<div class="line"><span class="lineno">  518</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::remove_reference&lt;</div>
<div class="line"><span class="lineno">  519</span>                            M&gt;::type::is_gtest_matcher&gt;</div>
<div class="line"><span class="lineno">  520</span>  Matcher(M&amp;&amp; m)  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  521</span>      : internal::MatcherBase&lt;const <a class="code hl_namespace" href="a00327.html">std</a>::string&amp;&gt;(<a class="code hl_namespace" href="a00327.html">std</a>::forward&lt;M&gt;(m)) {}</div>
<div class="line"><span class="lineno">  522</span> </div>
<div class="line"><span class="lineno">  523</span>  <span class="comment">// Allows the user to write str instead of Eq(str) sometimes, where</span></div>
<div class="line"><span class="lineno">  524</span>  <span class="comment">// str is a std::string object.</span></div>
<div class="line"><span class="lineno">  525</span>  Matcher(<span class="keyword">const</span> std::string&amp; s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  526</span> </div>
<div class="line"><span class="lineno">  527</span>  <span class="comment">// Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.</span></div>
<div class="line"><span class="lineno">  528</span>  Matcher(<span class="keyword">const</span> <span class="keywordtype">char</span>* s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  529</span>};</div>
<div class="line"><span class="lineno">  530</span> </div>
<div class="line"><span class="lineno">  531</span><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="lineno">  532</span><span class="keyword">class </span><a class="code hl_define" href="a00197.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> Matcher&lt;<a class="code hl_namespace" href="a00327.html">std</a>::string&gt;</div>
<div class="line"><span class="lineno">  533</span>    : <span class="keyword">public</span> internal::MatcherBase&lt;std::string&gt; {</div>
<div class="line"><span class="lineno">  534</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  535</span>  Matcher() {}</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>  <span class="keyword">explicit</span> Matcher(<span class="keyword">const</span> MatcherInterface&lt;const std::string&amp;&gt;* impl)</div>
<div class="line"><span class="lineno">  538</span>      : internal::MatcherBase&lt;<a class="code hl_namespace" href="a00327.html">std</a>::string&gt;(impl) {}</div>
<div class="line"><span class="lineno">  539</span>  <span class="keyword">explicit</span> Matcher(<span class="keyword">const</span> MatcherInterface&lt;std::string&gt;* impl)</div>
<div class="line"><span class="lineno">  540</span>      : internal::MatcherBase&lt;<a class="code hl_namespace" href="a00327.html">std</a>::string&gt;(impl) {}</div>
<div class="line"><span class="lineno">  541</span> </div>
<div class="line"><span class="lineno">  542</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::remove_reference&lt;</div>
<div class="line"><span class="lineno">  543</span>                            M&gt;::type::is_gtest_matcher&gt;</div>
<div class="line"><span class="lineno">  544</span>  Matcher(M&amp;&amp; m)  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  545</span>      : internal::MatcherBase&lt;<a class="code hl_namespace" href="a00327.html">std</a>::string&gt;(<a class="code hl_namespace" href="a00327.html">std</a>::forward&lt;M&gt;(m)) {}</div>
<div class="line"><span class="lineno">  546</span> </div>
<div class="line"><span class="lineno">  547</span>  <span class="comment">// Allows the user to write str instead of Eq(str) sometimes, where</span></div>
<div class="line"><span class="lineno">  548</span>  <span class="comment">// str is a string object.</span></div>
<div class="line"><span class="lineno">  549</span>  Matcher(<span class="keyword">const</span> std::string&amp; s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  550</span> </div>
<div class="line"><span class="lineno">  551</span>  <span class="comment">// Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.</span></div>
<div class="line"><span class="lineno">  552</span>  Matcher(<span class="keyword">const</span> <span class="keywordtype">char</span>* s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  553</span>};</div>
<div class="line"><span class="lineno">  554</span> </div>
<div class="line"><span class="lineno">  555</span><span class="preprocessor">#if GTEST_INTERNAL_HAS_STRING_VIEW</span></div>
<div class="line"><span class="lineno">  556</span><span class="comment">// The following two specializations allow the user to write str</span></div>
<div class="line"><span class="lineno">  557</span><span class="comment">// instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a absl::string_view</span></div>
<div class="line"><span class="lineno">  558</span><span class="comment">// matcher is expected.</span></div>
<div class="line"><span class="lineno">  559</span><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="lineno">  560</span><span class="keyword">class </span><a class="code hl_define" href="a00197.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> Matcher&lt;const internal::StringView&amp;&gt;</div>
<div class="line"><span class="lineno">  561</span>    : <span class="keyword">public</span> internal::MatcherBase&lt;const internal::StringView&amp;&gt; {</div>
<div class="line"><span class="lineno">  562</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  563</span>  Matcher() {}</div>
<div class="line"><span class="lineno">  564</span> </div>
<div class="line"><span class="lineno">  565</span>  <span class="keyword">explicit</span> Matcher(<span class="keyword">const</span> MatcherInterface&lt;const internal::StringView&amp;&gt;* impl)</div>
<div class="line"><span class="lineno">  566</span>      : internal::MatcherBase&lt;const internal::StringView&amp;&gt;(impl) {}</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::remove_reference&lt;</div>
<div class="line"><span class="lineno">  569</span>                            M&gt;::type::is_gtest_matcher&gt;</div>
<div class="line"><span class="lineno">  570</span>  Matcher(M&amp;&amp; m)  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  571</span>      : internal::MatcherBase&lt;const internal::StringView&amp;&gt;(<a class="code hl_namespace" href="a00327.html">std</a>::forward&lt;M&gt;(m)) {</div>
<div class="line"><span class="lineno">  572</span>  }</div>
<div class="line"><span class="lineno">  573</span> </div>
<div class="line"><span class="lineno">  574</span>  <span class="comment">// Allows the user to write str instead of Eq(str) sometimes, where</span></div>
<div class="line"><span class="lineno">  575</span>  <span class="comment">// str is a std::string object.</span></div>
<div class="line"><span class="lineno">  576</span>  Matcher(<span class="keyword">const</span> std::string&amp; s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  577</span> </div>
<div class="line"><span class="lineno">  578</span>  <span class="comment">// Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.</span></div>
<div class="line"><span class="lineno">  579</span>  Matcher(<span class="keyword">const</span> <span class="keywordtype">char</span>* s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  580</span> </div>
<div class="line"><span class="lineno">  581</span>  <span class="comment">// Allows the user to pass absl::string_views or std::string_views directly.</span></div>
<div class="line"><span class="lineno">  582</span>  Matcher(internal::StringView s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  583</span>};</div>
<div class="line"><span class="lineno">  584</span> </div>
<div class="line"><span class="lineno">  585</span><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="lineno">  586</span><span class="keyword">class </span><a class="code hl_define" href="a00197.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> Matcher&lt;internal::StringView&gt;</div>
<div class="line"><span class="lineno">  587</span>    : <span class="keyword">public</span> internal::MatcherBase&lt;internal::StringView&gt; {</div>
<div class="line"><span class="lineno">  588</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  589</span>  Matcher() {}</div>
<div class="line"><span class="lineno">  590</span> </div>
<div class="line"><span class="lineno">  591</span>  <span class="keyword">explicit</span> Matcher(<span class="keyword">const</span> MatcherInterface&lt;const internal::StringView&amp;&gt;* impl)</div>
<div class="line"><span class="lineno">  592</span>      : internal::MatcherBase&lt;internal::StringView&gt;(impl) {}</div>
<div class="line"><span class="lineno">  593</span>  <span class="keyword">explicit</span> Matcher(<span class="keyword">const</span> MatcherInterface&lt;internal::StringView&gt;* impl)</div>
<div class="line"><span class="lineno">  594</span>      : internal::MatcherBase&lt;internal::StringView&gt;(impl) {}</div>
<div class="line"><span class="lineno">  595</span> </div>
<div class="line"><span class="lineno">  596</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::remove_reference&lt;</div>
<div class="line"><span class="lineno">  597</span>                            M&gt;::type::is_gtest_matcher&gt;</div>
<div class="line"><span class="lineno">  598</span>  Matcher(M&amp;&amp; m)  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  599</span>      : internal::MatcherBase&lt;internal::StringView&gt;(<a class="code hl_namespace" href="a00327.html">std</a>::forward&lt;M&gt;(m)) {}</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span>  <span class="comment">// Allows the user to write str instead of Eq(str) sometimes, where</span></div>
<div class="line"><span class="lineno">  602</span>  <span class="comment">// str is a std::string object.</span></div>
<div class="line"><span class="lineno">  603</span>  Matcher(<span class="keyword">const</span> std::string&amp; s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  604</span> </div>
<div class="line"><span class="lineno">  605</span>  <span class="comment">// Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.</span></div>
<div class="line"><span class="lineno">  606</span>  Matcher(<span class="keyword">const</span> <span class="keywordtype">char</span>* s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  607</span> </div>
<div class="line"><span class="lineno">  608</span>  <span class="comment">// Allows the user to pass absl::string_views or std::string_views directly.</span></div>
<div class="line"><span class="lineno">  609</span>  Matcher(internal::StringView s);  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">  610</span>};</div>
<div class="line"><span class="lineno">  611</span><span class="preprocessor">#endif  </span><span class="comment">// GTEST_INTERNAL_HAS_STRING_VIEW</span></div>
<div class="line"><span class="lineno">  612</span> </div>
<div class="line"><span class="lineno">  613</span><span class="comment">// Prints a matcher in a human-readable format.</span></div>
<div class="line"><span class="lineno">  614</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  615</span>std::ostream&amp; <a class="code hl_function" href="a00321.html#a2d038049296f23fb404311f974788cd3">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> Matcher&lt;T&gt;&amp; matcher) {</div>
<div class="line"><span class="lineno">  616</span>  matcher.DescribeTo(&amp;os);</div>
<div class="line"><span class="lineno">  617</span>  <span class="keywordflow">return</span> os;</div>
<div class="line"><span class="lineno">  618</span>}</div>
<div class="line"><span class="lineno">  619</span> </div>
<div class="line"><span class="lineno">  620</span><span class="comment">// The PolymorphicMatcher class template makes it easy to implement a</span></div>
<div class="line"><span class="lineno">  621</span><span class="comment">// polymorphic matcher (i.e. a matcher that can match values of more</span></div>
<div class="line"><span class="lineno">  622</span><span class="comment">// than one type, e.g. Eq(n) and NotNull()).</span></div>
<div class="line"><span class="lineno">  623</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  624</span><span class="comment">// To define a polymorphic matcher, a user should provide an Impl</span></div>
<div class="line"><span class="lineno">  625</span><span class="comment">// class that has a DescribeTo() method and a DescribeNegationTo()</span></div>
<div class="line"><span class="lineno">  626</span><span class="comment">// method, and define a member function (or member function template)</span></div>
<div class="line"><span class="lineno">  627</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  628</span><span class="comment">//   bool MatchAndExplain(const Value&amp; value,</span></div>
<div class="line"><span class="lineno">  629</span><span class="comment">//                        MatchResultListener* listener) const;</span></div>
<div class="line"><span class="lineno">  630</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  631</span><span class="comment">// See the definition of NotNull() for a complete example.</span></div>
<div class="line"><span class="lineno">  632</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> Impl&gt;</div>
<div class="line"><span class="lineno">  633</span><span class="keyword">class </span>PolymorphicMatcher {</div>
<div class="line"><span class="lineno">  634</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  635</span>  <span class="keyword">explicit</span> PolymorphicMatcher(<span class="keyword">const</span> Impl&amp; an_impl) : impl_(an_impl) {}</div>
<div class="line"><span class="lineno">  636</span> </div>
<div class="line"><span class="lineno">  637</span>  <span class="comment">// Returns a mutable reference to the underlying matcher</span></div>
<div class="line"><span class="lineno">  638</span>  <span class="comment">// implementation object.</span></div>
<div class="line"><span class="lineno">  639</span>  Impl&amp; mutable_impl() { <span class="keywordflow">return</span> impl_; }</div>
<div class="line"><span class="lineno">  640</span> </div>
<div class="line"><span class="lineno">  641</span>  <span class="comment">// Returns an immutable reference to the underlying matcher</span></div>
<div class="line"><span class="lineno">  642</span>  <span class="comment">// implementation object.</span></div>
<div class="line"><span class="lineno">  643</span>  <span class="keyword">const</span> Impl&amp; impl()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl_; }</div>
<div class="line"><span class="lineno">  644</span> </div>
<div class="line"><span class="lineno">  645</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  646</span>  <span class="keyword">operator</span> Matcher&lt;T&gt;()<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  647</span>    <span class="keywordflow">return</span> Matcher&lt;T&gt;(<span class="keyword">new</span> MonomorphicImpl&lt;const T&amp;&gt;(impl_));</div>
<div class="line"><span class="lineno">  648</span>  }</div>
<div class="line"><span class="lineno">  649</span> </div>
<div class="line"><span class="lineno">  650</span> <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">  651</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  652</span>  <span class="keyword">class </span>MonomorphicImpl : <span class="keyword">public</span> MatcherInterface&lt;T&gt; {</div>
<div class="line"><span class="lineno">  653</span>   <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  654</span>    <span class="keyword">explicit</span> MonomorphicImpl(<span class="keyword">const</span> Impl&amp; impl) : impl_(impl) {}</div>
<div class="line"><span class="lineno">  655</span> </div>
<div class="line"><span class="lineno">  656</span>    <span class="keywordtype">void</span> DescribeTo(::std::ostream* os)<span class="keyword"> const override </span>{ impl_.DescribeTo(os); }</div>
<div class="line"><span class="lineno">  657</span> </div>
<div class="line"><span class="lineno">  658</span>    <span class="keywordtype">void</span> DescribeNegationTo(::std::ostream* os)<span class="keyword"> const override </span>{</div>
<div class="line"><span class="lineno">  659</span>      impl_.DescribeNegationTo(os);</div>
<div class="line"><span class="lineno">  660</span>    }</div>
<div class="line"><span class="lineno">  661</span> </div>
<div class="line"><span class="lineno">  662</span>    <span class="keywordtype">bool</span> MatchAndExplain(T x, MatchResultListener* listener)<span class="keyword"> const override </span>{</div>
<div class="line"><span class="lineno">  663</span>      <span class="keywordflow">return</span> impl_.MatchAndExplain(x, listener);</div>
<div class="line"><span class="lineno">  664</span>    }</div>
<div class="line"><span class="lineno">  665</span> </div>
<div class="line"><span class="lineno">  666</span>   <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">  667</span>    <span class="keyword">const</span> Impl impl_;</div>
<div class="line"><span class="lineno">  668</span>  };</div>
<div class="line"><span class="lineno">  669</span> </div>
<div class="line"><span class="lineno">  670</span>  Impl impl_;</div>
<div class="line"><span class="lineno">  671</span>};</div>
<div class="line"><span class="lineno">  672</span> </div>
<div class="line"><span class="lineno">  673</span><span class="comment">// Creates a matcher from its implementation.</span></div>
<div class="line"><span class="lineno">  674</span><span class="comment">// DEPRECATED: Especially in the generic code, prefer:</span></div>
<div class="line"><span class="lineno">  675</span><span class="comment">//   Matcher&lt;T&gt;(new MyMatcherImpl&lt;const T&amp;&gt;(...));</span></div>
<div class="line"><span class="lineno">  676</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  677</span><span class="comment">// MakeMatcher may create a Matcher that accepts its argument by value, which</span></div>
<div class="line"><span class="lineno">  678</span><span class="comment">// leads to unnecessary copies &amp; lack of support for non-copyable types.</span></div>
<div class="line"><span class="lineno">  679</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  680</span><span class="keyword">inline</span> Matcher&lt;T&gt; MakeMatcher(<span class="keyword">const</span> MatcherInterface&lt;T&gt;* impl) {</div>
<div class="line"><span class="lineno">  681</span>  <span class="keywordflow">return</span> Matcher&lt;T&gt;(impl);</div>
<div class="line"><span class="lineno">  682</span>}</div>
<div class="line"><span class="lineno">  683</span> </div>
<div class="line"><span class="lineno">  684</span><span class="comment">// Creates a polymorphic matcher from its implementation.  This is</span></div>
<div class="line"><span class="lineno">  685</span><span class="comment">// easier to use than the PolymorphicMatcher&lt;Impl&gt; constructor as it</span></div>
<div class="line"><span class="lineno">  686</span><span class="comment">// doesn&#39;t require you to explicitly write the template argument, e.g.</span></div>
<div class="line"><span class="lineno">  687</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  688</span><span class="comment">//   MakePolymorphicMatcher(foo);</span></div>
<div class="line"><span class="lineno">  689</span><span class="comment">// vs</span></div>
<div class="line"><span class="lineno">  690</span><span class="comment">//   PolymorphicMatcher&lt;TypeOfFoo&gt;(foo);</span></div>
<div class="line"><span class="lineno">  691</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> Impl&gt;</div>
<div class="line"><span class="lineno">  692</span><span class="keyword">inline</span> PolymorphicMatcher&lt;Impl&gt; MakePolymorphicMatcher(<span class="keyword">const</span> Impl&amp; impl) {</div>
<div class="line"><span class="lineno">  693</span>  <span class="keywordflow">return</span> PolymorphicMatcher&lt;Impl&gt;(impl);</div>
<div class="line"><span class="lineno">  694</span>}</div>
<div class="line"><span class="lineno">  695</span> </div>
<div class="line"><span class="lineno">  696</span><span class="keyword">namespace </span>internal {</div>
<div class="line"><span class="lineno">  697</span><span class="comment">// Implements a matcher that compares a given value with a</span></div>
<div class="line"><span class="lineno">  698</span><span class="comment">// pre-supplied value using one of the ==, &lt;=, &lt;, etc, operators.  The</span></div>
<div class="line"><span class="lineno">  699</span><span class="comment">// two values being compared don&#39;t have to have the same type.</span></div>
<div class="line"><span class="lineno">  700</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  701</span><span class="comment">// The matcher defined here is polymorphic (for example, Eq(5) can be</span></div>
<div class="line"><span class="lineno">  702</span><span class="comment">// used to match an int, a short, a double, etc).  Therefore we use</span></div>
<div class="line"><span class="lineno">  703</span><span class="comment">// a template type conversion operator in the implementation.</span></div>
<div class="line"><span class="lineno">  704</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  705</span><span class="comment">// The following template definition assumes that the Rhs parameter is</span></div>
<div class="line"><span class="lineno">  706</span><span class="comment">// a &quot;bare&quot; type (i.e. neither &#39;const T&#39; nor &#39;T&amp;&#39;).</span></div>
<div class="line"><span class="lineno">  707</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D, <span class="keyword">typename</span> Rhs, <span class="keyword">typename</span> Op&gt;</div>
<div class="line"><span class="lineno">  708</span><span class="keyword">class </span>ComparisonBase {</div>
<div class="line"><span class="lineno">  709</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  710</span>  <span class="keyword">explicit</span> ComparisonBase(<span class="keyword">const</span> Rhs&amp; rhs) : rhs_(rhs) {}</div>
<div class="line"><span class="lineno">  711</span> </div>
<div class="line"><span class="lineno">  712</span>  <span class="keyword">using</span> is_gtest_matcher = void;</div>
<div class="line"><span class="lineno">  713</span> </div>
<div class="line"><span class="lineno">  714</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Lhs&gt;</div>
<div class="line"><span class="lineno">  715</span>  <span class="keywordtype">bool</span> MatchAndExplain(<span class="keyword">const</span> Lhs&amp; lhs, std::ostream*)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  716</span>    <span class="keywordflow">return</span> Op()(lhs, Unwrap(rhs_));</div>
<div class="line"><span class="lineno">  717</span>  }</div>
<div class="line"><span class="lineno">  718</span>  <span class="keywordtype">void</span> DescribeTo(std::ostream* os)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  719</span>    *os &lt;&lt; D::Desc() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno">  720</span>    <a class="code hl_function" href="a00322.html#a30708fa2bacf11895b03bdb21eb72309">UniversalPrint</a>(Unwrap(rhs_), os);</div>
<div class="line"><span class="lineno">  721</span>  }</div>
<div class="line"><span class="lineno">  722</span>  <span class="keywordtype">void</span> DescribeNegationTo(std::ostream* os)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  723</span>    *os &lt;&lt; D::NegatedDesc() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno">  724</span>    <a class="code hl_function" href="a00322.html#a30708fa2bacf11895b03bdb21eb72309">UniversalPrint</a>(Unwrap(rhs_), os);</div>
<div class="line"><span class="lineno">  725</span>  }</div>
<div class="line"><span class="lineno">  726</span> </div>
<div class="line"><span class="lineno">  727</span> <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">  728</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  729</span>  <span class="keyword">static</span> <span class="keyword">const</span> T&amp; Unwrap(<span class="keyword">const</span> T&amp; v) {</div>
<div class="line"><span class="lineno">  730</span>    <span class="keywordflow">return</span> v;</div>
<div class="line"><span class="lineno">  731</span>  }</div>
<div class="line"><span class="lineno">  732</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  733</span>  <span class="keyword">static</span> <span class="keyword">const</span> T&amp; Unwrap(std::reference_wrapper&lt;T&gt; v) {</div>
<div class="line"><span class="lineno">  734</span>    <span class="keywordflow">return</span> v;</div>
<div class="line"><span class="lineno">  735</span>  }</div>
<div class="line"><span class="lineno">  736</span> </div>
<div class="line"><span class="lineno">  737</span>  Rhs rhs_;</div>
<div class="line"><span class="lineno">  738</span>};</div>
<div class="line"><span class="lineno">  739</span> </div>
<div class="line"><span class="lineno">  740</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  741</span><span class="keyword">class </span>EqMatcher : <span class="keyword">public</span> ComparisonBase&lt;EqMatcher&lt;Rhs&gt;, Rhs, AnyEq&gt; {</div>
<div class="line"><span class="lineno">  742</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  743</span>  <span class="keyword">explicit</span> EqMatcher(<span class="keyword">const</span> Rhs&amp; rhs)</div>
<div class="line"><span class="lineno">  744</span>      : ComparisonBase&lt;EqMatcher&lt;Rhs&gt;, Rhs, AnyEq&gt;(rhs) { }</div>
<div class="line"><span class="lineno">  745</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Desc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;is equal to&quot;</span>; }</div>
<div class="line"><span class="lineno">  746</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* NegatedDesc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;isn&#39;t equal to&quot;</span>; }</div>
<div class="line"><span class="lineno">  747</span>};</div>
<div class="line"><span class="lineno">  748</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  749</span><span class="keyword">class </span>NeMatcher : <span class="keyword">public</span> ComparisonBase&lt;NeMatcher&lt;Rhs&gt;, Rhs, AnyNe&gt; {</div>
<div class="line"><span class="lineno">  750</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  751</span>  <span class="keyword">explicit</span> NeMatcher(<span class="keyword">const</span> Rhs&amp; rhs)</div>
<div class="line"><span class="lineno">  752</span>      : ComparisonBase&lt;NeMatcher&lt;Rhs&gt;, Rhs, AnyNe&gt;(rhs) { }</div>
<div class="line"><span class="lineno">  753</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Desc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;isn&#39;t equal to&quot;</span>; }</div>
<div class="line"><span class="lineno">  754</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* NegatedDesc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;is equal to&quot;</span>; }</div>
<div class="line"><span class="lineno">  755</span>};</div>
<div class="line"><span class="lineno">  756</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  757</span><span class="keyword">class </span>LtMatcher : <span class="keyword">public</span> ComparisonBase&lt;LtMatcher&lt;Rhs&gt;, Rhs, AnyLt&gt; {</div>
<div class="line"><span class="lineno">  758</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  759</span>  <span class="keyword">explicit</span> LtMatcher(<span class="keyword">const</span> Rhs&amp; rhs)</div>
<div class="line"><span class="lineno">  760</span>      : ComparisonBase&lt;LtMatcher&lt;Rhs&gt;, Rhs, AnyLt&gt;(rhs) { }</div>
<div class="line"><span class="lineno">  761</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Desc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;is &lt;&quot;</span>; }</div>
<div class="line"><span class="lineno">  762</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* NegatedDesc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;isn&#39;t &lt;&quot;</span>; }</div>
<div class="line"><span class="lineno">  763</span>};</div>
<div class="line"><span class="lineno">  764</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  765</span><span class="keyword">class </span>GtMatcher : <span class="keyword">public</span> ComparisonBase&lt;GtMatcher&lt;Rhs&gt;, Rhs, AnyGt&gt; {</div>
<div class="line"><span class="lineno">  766</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  767</span>  <span class="keyword">explicit</span> GtMatcher(<span class="keyword">const</span> Rhs&amp; rhs)</div>
<div class="line"><span class="lineno">  768</span>      : ComparisonBase&lt;GtMatcher&lt;Rhs&gt;, Rhs, AnyGt&gt;(rhs) { }</div>
<div class="line"><span class="lineno">  769</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Desc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;is &gt;&quot;</span>; }</div>
<div class="line"><span class="lineno">  770</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* NegatedDesc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;isn&#39;t &gt;&quot;</span>; }</div>
<div class="line"><span class="lineno">  771</span>};</div>
<div class="line"><span class="lineno">  772</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  773</span><span class="keyword">class </span>LeMatcher : <span class="keyword">public</span> ComparisonBase&lt;LeMatcher&lt;Rhs&gt;, Rhs, AnyLe&gt; {</div>
<div class="line"><span class="lineno">  774</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  775</span>  <span class="keyword">explicit</span> LeMatcher(<span class="keyword">const</span> Rhs&amp; rhs)</div>
<div class="line"><span class="lineno">  776</span>      : ComparisonBase&lt;LeMatcher&lt;Rhs&gt;, Rhs, AnyLe&gt;(rhs) { }</div>
<div class="line"><span class="lineno">  777</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Desc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;is &lt;=&quot;</span>; }</div>
<div class="line"><span class="lineno">  778</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* NegatedDesc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;isn&#39;t &lt;=&quot;</span>; }</div>
<div class="line"><span class="lineno">  779</span>};</div>
<div class="line"><span class="lineno">  780</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  781</span><span class="keyword">class </span>GeMatcher : <span class="keyword">public</span> ComparisonBase&lt;GeMatcher&lt;Rhs&gt;, Rhs, AnyGe&gt; {</div>
<div class="line"><span class="lineno">  782</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  783</span>  <span class="keyword">explicit</span> GeMatcher(<span class="keyword">const</span> Rhs&amp; rhs)</div>
<div class="line"><span class="lineno">  784</span>      : ComparisonBase&lt;GeMatcher&lt;Rhs&gt;, Rhs, AnyGe&gt;(rhs) { }</div>
<div class="line"><span class="lineno">  785</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Desc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;is &gt;=&quot;</span>; }</div>
<div class="line"><span class="lineno">  786</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* NegatedDesc() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;isn&#39;t &gt;=&quot;</span>; }</div>
<div class="line"><span class="lineno">  787</span>};</div>
<div class="line"><span class="lineno">  788</span> </div>
<div class="line"><span class="lineno">  789</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</div>
<div class="line"><span class="lineno">  790</span>                          std::is_constructible&lt;std::string, T&gt;::value&gt;::type&gt;</div>
<div class="line"><span class="lineno">  791</span><span class="keyword">using</span> StringLike = T;</div>
<div class="line"><span class="lineno">  792</span> </div>
<div class="line"><span class="lineno">  793</span><span class="comment">// Implements polymorphic matchers MatchesRegex(regex) and</span></div>
<div class="line"><span class="lineno">  794</span><span class="comment">// ContainsRegex(regex), which can be used as a Matcher&lt;T&gt; as long as</span></div>
<div class="line"><span class="lineno">  795</span><span class="comment">// T can be converted to a string.</span></div>
<div class="line"><span class="lineno">  796</span><span class="keyword">class </span>MatchesRegexMatcher {</div>
<div class="line"><span class="lineno">  797</span> <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">  798</span>  MatchesRegexMatcher(<span class="keyword">const</span> RE* regex, <span class="keywordtype">bool</span> full_match)</div>
<div class="line"><span class="lineno">  799</span>      : regex_(regex), full_match_(full_match) {}</div>
<div class="line"><span class="lineno">  800</span> </div>
<div class="line"><span class="lineno">  801</span><span class="preprocessor">#if GTEST_INTERNAL_HAS_STRING_VIEW</span></div>
<div class="line"><span class="lineno">  802</span>  <span class="keywordtype">bool</span> MatchAndExplain(<span class="keyword">const</span> internal::StringView&amp; s,</div>
<div class="line"><span class="lineno">  803</span>                       MatchResultListener* listener)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  804</span>    <span class="keywordflow">return</span> MatchAndExplain(std::string(s), listener);</div>
<div class="line"><span class="lineno">  805</span>  }</div>
<div class="line"><span class="lineno">  806</span><span class="preprocessor">#endif  </span><span class="comment">// GTEST_INTERNAL_HAS_STRING_VIEW</span></div>
<div class="line"><span class="lineno">  807</span> </div>
<div class="line"><span class="lineno">  808</span>  <span class="comment">// Accepts pointer types, particularly:</span></div>
<div class="line"><span class="lineno">  809</span>  <span class="comment">//   const char*</span></div>
<div class="line"><span class="lineno">  810</span>  <span class="comment">//   char*</span></div>
<div class="line"><span class="lineno">  811</span>  <span class="comment">//   const wchar_t*</span></div>
<div class="line"><span class="lineno">  812</span>  <span class="comment">//   wchar_t*</span></div>
<div class="line"><span class="lineno">  813</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType&gt;</div>
<div class="line"><span class="lineno">  814</span>  <span class="keywordtype">bool</span> MatchAndExplain(CharType* s, MatchResultListener* listener)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  815</span>    <span class="keywordflow">return</span> s != <span class="keyword">nullptr</span> &amp;&amp; MatchAndExplain(std::string(s), listener);</div>
<div class="line"><span class="lineno">  816</span>  }</div>
<div class="line"><span class="lineno">  817</span> </div>
<div class="line"><span class="lineno">  818</span>  <span class="comment">// Matches anything that can convert to std::string.</span></div>
<div class="line"><span class="lineno">  819</span>  <span class="comment">//</span></div>
<div class="line"><span class="lineno">  820</span>  <span class="comment">// This is a template, not just a plain function with const std::string&amp;,</span></div>
<div class="line"><span class="lineno">  821</span>  <span class="comment">// because absl::string_view has some interfering non-explicit constructors.</span></div>
<div class="line"><span class="lineno">  822</span>  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatcheeStringType&gt;</div>
<div class="line"><span class="lineno">  823</span>  <span class="keywordtype">bool</span> MatchAndExplain(<span class="keyword">const</span> MatcheeStringType&amp; s,</div>
<div class="line"><span class="lineno">  824</span>                       MatchResultListener* <span class="comment">/* listener */</span>)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  825</span>    <span class="keyword">const</span> std::string&amp; s2(s);</div>
<div class="line"><span class="lineno">  826</span>    <span class="keywordflow">return</span> full_match_ ? RE::FullMatch(s2, *regex_)</div>
<div class="line"><span class="lineno">  827</span>                       : RE::PartialMatch(s2, *regex_);</div>
<div class="line"><span class="lineno">  828</span>  }</div>
<div class="line"><span class="lineno">  829</span> </div>
<div class="line"><span class="lineno">  830</span>  <span class="keywordtype">void</span> DescribeTo(::std::ostream* os)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  831</span>    *os &lt;&lt; (full_match_ ? <span class="stringliteral">&quot;matches&quot;</span> : <span class="stringliteral">&quot;contains&quot;</span>) &lt;&lt; <span class="stringliteral">&quot; regular expression &quot;</span>;</div>
<div class="line"><span class="lineno">  832</span>    UniversalPrinter&lt;std::string&gt;::Print(regex_-&gt;pattern(), os);</div>
<div class="line"><span class="lineno">  833</span>  }</div>
<div class="line"><span class="lineno">  834</span> </div>
<div class="line"><span class="lineno">  835</span>  <span class="keywordtype">void</span> DescribeNegationTo(::std::ostream* os)<span class="keyword"> const </span>{</div>
<div class="line"><span class="lineno">  836</span>    *os &lt;&lt; <span class="stringliteral">&quot;doesn&#39;t &quot;</span> &lt;&lt; (full_match_ ? <span class="stringliteral">&quot;match&quot;</span> : <span class="stringliteral">&quot;contain&quot;</span>)</div>
<div class="line"><span class="lineno">  837</span>        &lt;&lt; <span class="stringliteral">&quot; regular expression &quot;</span>;</div>
<div class="line"><span class="lineno">  838</span>    UniversalPrinter&lt;std::string&gt;::Print(regex_-&gt;pattern(), os);</div>
<div class="line"><span class="lineno">  839</span>  }</div>
<div class="line"><span class="lineno">  840</span> </div>
<div class="line"><span class="lineno">  841</span> <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">  842</span>  <span class="keyword">const</span> std::shared_ptr&lt;const RE&gt; regex_;</div>
<div class="line"><span class="lineno">  843</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> full_match_;</div>
<div class="line"><span class="lineno">  844</span>};</div>
<div class="line"><span class="lineno">  845</span>}  <span class="comment">// namespace internal</span></div>
<div class="line"><span class="lineno">  846</span> </div>
<div class="line"><span class="lineno">  847</span><span class="comment">// Matches a string that fully matches regular expression &#39;regex&#39;.</span></div>
<div class="line"><span class="lineno">  848</span><span class="comment">// The matcher takes ownership of &#39;regex&#39;.</span></div>
<div class="line"><span class="lineno">  849</span><span class="keyword">inline</span> PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; MatchesRegex(</div>
<div class="line"><span class="lineno">  850</span>    <span class="keyword">const</span> internal::RE* regex) {</div>
<div class="line"><span class="lineno">  851</span>  <span class="keywordflow">return</span> MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, <span class="keyword">true</span>));</div>
<div class="line"><span class="lineno">  852</span>}</div>
<div class="line"><span class="lineno">  853</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = std::<span class="keywordtype">string</span>&gt;</div>
<div class="line"><span class="lineno">  854</span>PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; MatchesRegex(</div>
<div class="line"><span class="lineno">  855</span>    <span class="keyword">const</span> internal::StringLike&lt;T&gt;&amp; regex) {</div>
<div class="line"><span class="lineno">  856</span>  <span class="keywordflow">return</span> MatchesRegex(<span class="keyword">new</span> internal::RE(std::string(regex)));</div>
<div class="line"><span class="lineno">  857</span>}</div>
<div class="line"><span class="lineno">  858</span> </div>
<div class="line"><span class="lineno">  859</span><span class="comment">// Matches a string that contains regular expression &#39;regex&#39;.</span></div>
<div class="line"><span class="lineno">  860</span><span class="comment">// The matcher takes ownership of &#39;regex&#39;.</span></div>
<div class="line"><span class="lineno">  861</span><span class="keyword">inline</span> PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; ContainsRegex(</div>
<div class="line"><span class="lineno">  862</span>    <span class="keyword">const</span> internal::RE* regex) {</div>
<div class="line"><span class="lineno">  863</span>  <span class="keywordflow">return</span> MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, <span class="keyword">false</span>));</div>
<div class="line"><span class="lineno">  864</span>}</div>
<div class="line"><span class="lineno">  865</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = std::<span class="keywordtype">string</span>&gt;</div>
<div class="line"><span class="lineno">  866</span>PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; ContainsRegex(</div>
<div class="line"><span class="lineno">  867</span>    <span class="keyword">const</span> internal::StringLike&lt;T&gt;&amp; regex) {</div>
<div class="line"><span class="lineno">  868</span>  <span class="keywordflow">return</span> ContainsRegex(<span class="keyword">new</span> internal::RE(std::string(regex)));</div>
<div class="line"><span class="lineno">  869</span>}</div>
<div class="line"><span class="lineno">  870</span> </div>
<div class="line"><span class="lineno">  871</span><span class="comment">// Creates a polymorphic matcher that matches anything equal to x.</span></div>
<div class="line"><span class="lineno">  872</span><span class="comment">// Note: if the parameter of Eq() were declared as const T&amp;, Eq(&quot;foo&quot;)</span></div>
<div class="line"><span class="lineno">  873</span><span class="comment">// wouldn&#39;t compile.</span></div>
<div class="line"><span class="lineno">  874</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  875</span><span class="keyword">inline</span> internal::EqMatcher&lt;T&gt; Eq(T x) { <span class="keywordflow">return</span> internal::EqMatcher&lt;T&gt;(x); }</div>
<div class="line"><span class="lineno">  876</span> </div>
<div class="line"><span class="lineno">  877</span><span class="comment">// Constructs a Matcher&lt;T&gt; from a &#39;value&#39; of type T.  The constructed</span></div>
<div class="line"><span class="lineno">  878</span><span class="comment">// matcher matches any value that&#39;s equal to &#39;value&#39;.</span></div>
<div class="line"><span class="lineno">  879</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="lineno">  880</span>Matcher&lt;T&gt;::Matcher(T value) { *<span class="keyword">this</span> = Eq(value); }</div>
<div class="line"><span class="lineno">  881</span> </div>
<div class="line"><span class="lineno">  882</span><span class="comment">// Creates a monomorphic matcher that matches anything with type Lhs</span></div>
<div class="line"><span class="lineno">  883</span><span class="comment">// and equal to rhs.  A user may need to use this instead of Eq(...)</span></div>
<div class="line"><span class="lineno">  884</span><span class="comment">// in order to resolve an overloading ambiguity.</span></div>
<div class="line"><span class="lineno">  885</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  886</span><span class="comment">// TypedEq&lt;T&gt;(x) is just a convenient short-hand for Matcher&lt;T&gt;(Eq(x))</span></div>
<div class="line"><span class="lineno">  887</span><span class="comment">// or Matcher&lt;T&gt;(x), but more readable than the latter.</span></div>
<div class="line"><span class="lineno">  888</span><span class="comment">//</span></div>
<div class="line"><span class="lineno">  889</span><span class="comment">// We could define similar monomorphic matchers for other comparison</span></div>
<div class="line"><span class="lineno">  890</span><span class="comment">// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do</span></div>
<div class="line"><span class="lineno">  891</span><span class="comment">// it yet as those are used much less than Eq() in practice.  A user</span></div>
<div class="line"><span class="lineno">  892</span><span class="comment">// can always write Matcher&lt;T&gt;(Lt(5)) to be explicit about the type,</span></div>
<div class="line"><span class="lineno">  893</span><span class="comment">// for example.</span></div>
<div class="line"><span class="lineno">  894</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Lhs, <span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  895</span><span class="keyword">inline</span> Matcher&lt;Lhs&gt; TypedEq(<span class="keyword">const</span> Rhs&amp; rhs) { <span class="keywordflow">return</span> Eq(rhs); }</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span><span class="comment">// Creates a polymorphic matcher that matches anything &gt;= x.</span></div>
<div class="line"><span class="lineno">  898</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  899</span><span class="keyword">inline</span> internal::GeMatcher&lt;Rhs&gt; Ge(Rhs x) {</div>
<div class="line"><span class="lineno">  900</span>  <span class="keywordflow">return</span> internal::GeMatcher&lt;Rhs&gt;(x);</div>
<div class="line"><span class="lineno">  901</span>}</div>
<div class="line"><span class="lineno">  902</span> </div>
<div class="line"><span class="lineno">  903</span><span class="comment">// Creates a polymorphic matcher that matches anything &gt; x.</span></div>
<div class="line"><span class="lineno">  904</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  905</span><span class="keyword">inline</span> internal::GtMatcher&lt;Rhs&gt; Gt(Rhs x) {</div>
<div class="line"><span class="lineno">  906</span>  <span class="keywordflow">return</span> internal::GtMatcher&lt;Rhs&gt;(x);</div>
<div class="line"><span class="lineno">  907</span>}</div>
<div class="line"><span class="lineno">  908</span> </div>
<div class="line"><span class="lineno">  909</span><span class="comment">// Creates a polymorphic matcher that matches anything &lt;= x.</span></div>
<div class="line"><span class="lineno">  910</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  911</span><span class="keyword">inline</span> internal::LeMatcher&lt;Rhs&gt; Le(Rhs x) {</div>
<div class="line"><span class="lineno">  912</span>  <span class="keywordflow">return</span> internal::LeMatcher&lt;Rhs&gt;(x);</div>
<div class="line"><span class="lineno">  913</span>}</div>
<div class="line"><span class="lineno">  914</span> </div>
<div class="line"><span class="lineno">  915</span><span class="comment">// Creates a polymorphic matcher that matches anything &lt; x.</span></div>
<div class="line"><span class="lineno">  916</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  917</span><span class="keyword">inline</span> internal::LtMatcher&lt;Rhs&gt; Lt(Rhs x) {</div>
<div class="line"><span class="lineno">  918</span>  <span class="keywordflow">return</span> internal::LtMatcher&lt;Rhs&gt;(x);</div>
<div class="line"><span class="lineno">  919</span>}</div>
<div class="line"><span class="lineno">  920</span> </div>
<div class="line"><span class="lineno">  921</span><span class="comment">// Creates a polymorphic matcher that matches anything != x.</span></div>
<div class="line"><span class="lineno">  922</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="lineno">  923</span><span class="keyword">inline</span> internal::NeMatcher&lt;Rhs&gt; Ne(Rhs x) {</div>
<div class="line"><span class="lineno">  924</span>  <span class="keywordflow">return</span> internal::NeMatcher&lt;Rhs&gt;(x);</div>
<div class="line"><span class="lineno">  925</span>}</div>
<div class="line"><span class="lineno">  926</span>}  <span class="comment">// namespace testing</span></div>
<div class="ttc" id="aa00116_html_a65e9886d74aaee76545e83dd09011727"><div class="ttname"><a href="a00116.html#a65e9886d74aaee76545e83dd09011727">false</a></div><div class="ttdeci">#define false</div><div class="ttdef"><b>Definition:</b> <a href="a00116_source.html#l00098">s7.h:98</a></div></div>
<div class="ttc" id="aa00116_html_abb452686968e48b67397da5f97445f5b"><div class="ttname"><a href="a00116.html#abb452686968e48b67397da5f97445f5b">bool</a></div><div class="ttdeci">#define bool</div><div class="ttdef"><b>Definition:</b> <a href="a00116_source.html#l00096">s7.h:96</a></div></div>
<div class="ttc" id="aa00197_html_aa73be6f0ba4a7456180a94904ce17790"><div class="ttname"><a href="a00197.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a></div><div class="ttdeci">#define GTEST_API_</div><div class="ttdef"><b>Definition:</b> <a href="a00197_source.html#l00789">gtest-port.h:789</a></div></div>
<div class="ttc" id="aa00197_html_ab54343f0a36dc4cb0ce8a478dd7847b8"><div class="ttname"><a href="a00197.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a></div><div class="ttdeci">#define GTEST_CHECK_(condition)</div><div class="ttdef"><b>Definition:</b> <a href="a00197_source.html#l01018">gtest-port.h:1018</a></div></div>
<div class="ttc" id="aa00197_html_aed8c1888c32b588b0681e88b95031e29"><div class="ttname"><a href="a00197.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a></div><div class="ttdeci">#define GTEST_DISALLOW_COPY_AND_ASSIGN_(type)</div><div class="ttdef"><b>Definition:</b> <a href="a00197_source.html#l00699">gtest-port.h:699</a></div></div>
<div class="ttc" id="aa00321_html_a2d038049296f23fb404311f974788cd3"><div class="ttname"><a href="a00321.html#a2d038049296f23fb404311f974788cd3">testing::operator&lt;&lt;</a></div><div class="ttdeci">std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const Message &amp;sb)</div><div class="ttdef"><b>Definition:</b> <a href="a00221_source.html#l00197">gtest-message.h:197</a></div></div>
<div class="ttc" id="aa00322_html_a30708fa2bacf11895b03bdb21eb72309"><div class="ttname"><a href="a00322.html#a30708fa2bacf11895b03bdb21eb72309">testing::internal::UniversalPrint</a></div><div class="ttdeci">void UniversalPrint(const T &amp;value, ::std::ostream *os)</div><div class="ttdef"><b>Definition:</b> <a href="a00194_source.html#l00994">gtest-printers.h:994</a></div></div>
<div class="ttc" id="aa00327_html"><div class="ttname"><a href="a00327.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="a00212_source.html#l01320">gtest-internal.h:1320</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00116_source.html#l00096">bool</a>, <a class="el" href="a00116_source.html#l00098">false</a>, <a class="el" href="a00197_source.html#l00922">testing::internal::RE::FullMatch()</a>, <a class="el" href="a00197_source.html#l00789">GTEST_API_</a>, <a class="el" href="a00197_source.html#l01018">GTEST_CHECK_</a>, <a class="el" href="a00197_source.html#l00699">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>, <a class="el" href="a00221_source.html#l00197">testing::operator&lt;&lt;()</a>, <a class="el" href="a00197_source.html#l00925">testing::internal::RE::PartialMatch()</a>, <a class="el" href="a00194_source.html#l00692">testing::internal::UniversalPrinter&lt; T &gt;::Print()</a>, and <a class="el" href="a00194_source.html#l00994">testing::internal::UniversalPrint()</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00239_ae9b7a8d33bcb4bbad774b324eeeb23d6_cgraph.png" border="0" usemap="#aa00239_ae9b7a8d33bcb4bbad774b324eeeb23d6_cgraph" alt=""/></div>
<map name="aa00239_ae9b7a8d33bcb4bbad774b324eeeb23d6_cgraph" id="aa00239_ae9b7a8d33bcb4bbad774b324eeeb23d6_cgraph">
<area shape="rect" title=" " alt="" coords="5,123,249,164"/>
<area shape="rect" href="a01176.html#aa79a950758d0f1d62f7762d1e9cefe86" title=" " alt="" coords="305,5,420,47"/>
<area shape="rect" href="a00321.html#a2d038049296f23fb404311f974788cd3" title=" " alt="" coords="297,71,428,98"/>
<area shape="rect" href="a01176.html#a1e81f9a87211bdca645e025f8f0236c8" title=" " alt="" coords="303,123,422,164"/>
<area shape="rect" href="a00760.html#aecec021e1abbaa260b701e24e3fe33eb" title=" " alt="" coords="493,211,641,252"/>
<area shape="rect" href="a00322.html#a30708fa2bacf11895b03bdb21eb72309" title=" " alt="" coords="305,240,420,281"/>
<area shape="rect" href="a00700.html#a2cdc4df62bdcc9df37651a1cf527704e" title=" " alt="" coords="476,71,657,98"/>
<area shape="rect" href="a00322.html#adb3c27150dbe661db0e0c4be27533460" title=" " alt="" coords="705,211,820,252"/>
<area shape="rect" href="a00322.html#a5e9f744566e02ba3f811cd51d3b8c4fb" title=" " alt="" coords="868,211,992,252"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 6 2022 12:24:15 for MUSI6106 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
